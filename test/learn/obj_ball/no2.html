<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Bouncing balls</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
</head>

<body>
    <input type="button" value="change" onclick="changeShap()" />
    <input id="shapID" type="input" value="" />
    <canvas id="myCanvas"></canvas>

    <script>
        // setup canvas
        var canvas = document.querySelector('canvas'); //符合css選擇器
        var ctx = canvas.getContext('2d');
        var width = canvas.width = window.innerWidth;
        var height = canvas.height = window.innerHeight;
		    var zeroX = width / 2;
            var zeroY = height / 2;
        var count = 0;
        //儲存彩球 
        var balls = [];
        // function to generate random number
        var XposAry1 = [];
        var YposAry1 = [];
		var baseShap =makeBaseAnimine();
        var XposAry2 = baseShap[0];
        var YposAry2 = baseShap[1];
        var ballNum = 100;
		
		
		
        function random(min, max) { //起始值，最大值，回傳這區間的一個數
            var num = Math.floor(Math.random() * (max - min)) + min;
            return num;
        }
        //設定球體模型 (建構子) 屬性
        function Ball(x, y) {
            this.x = x; //random(0, width);
            this.y = y;
            / 2 / / random(0, height);
            this.velX = 10;
            this.velY = 10;
            this.color = 'rgb(' + random(20, 255) + ',' + random(20, 255) + ',' + random(200, 255) + ')';
            this.size = 2 //random(1, 2);
        }

        //繪製球體 建構子函式 原型繼承
        Ball.prototype.draw = function() {
            ctx.beginPath(); //聲明要在紙上畫出
            ctx.fillStyle = this.color; //要呈現的顏色
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI); //arc畫弧形 (中心xy，size半徑，始終角度0-2*180)
            ctx.fill(); //已完成形狀，並填滿fillStyle顏色
        }

        //碰撞換色
        Ball.prototype.collisionDetect = function() {
            for (j = 0; j < balls.length; j++) {
                //判斷為不同球
                if ((!(this.x === balls[j].x && this.y === balls[j].y && this.velX === balls[j].velX && this.velY === balls[j].velY))) {
                    //var dx = this.x;
                    var dx = this.x - balls[j].x;
                    //var dy = this.y;
                    var dy = this.y - balls[j].y;
                    var distance = Math.sqrt(dx * dx + dy * dy);

                    //判斷邊緣相撞
                    if (distance < this.size + balls[j].size) {
                        // if (distance < 1) {
                        balls[j].color = this.color = 'rgb(' + random(0, 255) + ',' + random(0, 255) + ',' + random(0, 255) + ')';
                        //balls[j].velX = -(this.velX);
                        //balls[j].velY = -(this.velY);

                    }
                }
            }
        }

        //偵測碰撞4ㄍ邊緣
		//(重置)
        Ball.prototype.edgeDetect = function() {
			
			if ((this.y - this.size) <= 0||(this.x + this.size) >= width||(this.y + this.size) >= height||(this.y - this.size) <= 0) {
                //this.velY = -(this.velY);
				this.x = zeroX;
				this.y = zeroY;
            }
			
        }

        //更新球的資料 
        //軌跡、位移量
        var s = 1;
        var times = 1;
        Ball.prototype.update = function() {

            //this.x += this.velX * 0.01;
            //this.y += this.velY * 0.01;
            this.x += ((20) * Math.cos(s * Math.PI / 72) - (1) * Math.cos(s / 6) * (s * Math.PI / 72)) * 0.1;
            this.y += ((20) * Math.sin(s * Math.PI / 72) - (1) * Math.sin(s / 6) * (s * Math.PI / 72)) * 0.1;
            count++;
            s++;
            //            if(count%200==0){
            //                //this.x =width/2;
            //                //this.y =height/2;
            //                s=times*20;
            //                times++;
            //            }

        }



        //萬花筒函式
        function Spirograph(ctx, R, r, O) {
            var x1 = R - O;
            var y1 = 0;
            var i = 1;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            do {
                if (i > 20000) break;
                var x2 = (R + r) * Math.cos(i * Math.PI / 72) - (r + O) * Math.cos(((R + r) / r) * (i * Math.PI / 72))
                var y2 = (R + r) * Math.sin(i * Math.PI / 72) - (r + O) * Math.sin(((R + r) / r) * (i * Math.PI / 72))
                ctx.lineTo(x2, y2);
                x1 = x2;
                y1 = y2;
                i++;
            } while (x2 != R - O && y2 != 0);
            ctx.stroke();
        }

        //畫布平移至抹點開始畫
        function drawSpirograph(ctx) {
            ctx.fillRect(0, 0, 300, 300);
            for (var i = 0; i < 3; i++) { //y軸平移
                for (var j = 0; j < 3; j++) { //x軸平移
                    ctx.save();
                    ctx.strokeStyle = "#9CFF00";
                    ctx.translate(50 + j * 100, 200 + i * 100);
                    Spirograph(ctx, 20 * (j + 2) / (j + 1), -8 * (i + 3) / (i + 1), 10);
                    ctx.restore();
                }
            }
        }
        //drawSpirograph(ctx);



        while (balls.length < ballNum) {
            var ball = new Ball(400, 400);
            balls.push(ball);
        }


        //造球
        var finish = true;
        var change = 0;

        function loop() {
		console.log(finish)
            ctx.fillStyle = 'rgba(220,200,220,0.05)'; //畫格填滿的顏色
            ctx.fillRect(0, 0, width, height); //填滿區
		
            for (i = 0; i < balls.length; i++) {
				balls[i].edgeDetect();
                if (finish == false) {
                    if (balls[i].x - 5 > XposAry1[i] || balls[i].x + 5 < XposAry1[i] || balls[i].y - 5 > YposAry1[i] || balls[i].y + 5 < YposAry1[i]) {
                        balls[i].x += (XposAry1[i] - balls[i].x) / 10 * Math.random();
                        balls[i].y += (YposAry1[i] - balls[i].y) / 10 * Math.random();
                    } else {
                        //balls[i].color = '#000000';
                        balls[i].x = XposAry1[i];
                        balls[i].y = YposAry1[i];
                        setTimeout(function(){
                        finish = true;
                        },5000);
                    }
                }else{
				
				//回到基底動畫位置
					if (balls[i].x - 5 > XposAry2[i] || balls[i].x + 5 < XposAry2[i] || balls[i].y - 5 > YposAry2[i] || balls[i].y + 5 < YposAry2[i]) {
                        balls[i].x += (XposAry2[i] - balls[i].x) / 10 * Math.random();
                        balls[i].y += (YposAry2[i] - balls[i].y) / 10 * Math.random();
                    } else {
					//基底動畫
                        balls[i].x +=random(-20, 20);
                        balls[i].y +=random(-10	, 10) ;
                    }

				}

                balls[i].draw();
            }
            count++; //從update搬來這裡

            if (count < 80000) {

                requestAnimationFrame(loop); //與瀏覽器繪製時間配合的
                //setTimeout(loop, 1000); //必較不好的繪製法

            };

        }
		
		function makeBaseAnimine(){
			var outAryX = [];
            var outAryY = [];
			var group = "";
			for (var i = 0; i < ballNum; i++) {
			outAryX.push(100*i);
			outAryY.push(222);
				//for (var j = 0; j < group; j++) {}
			}
		    return [outAryX, outAryY]
		}

        function makeCircle(oX,oY) {
            var radius = random(50,200);
            var beginX = oX - radius;
            var endX = oX - radius;
            var changeX = (radius * 2 / ballNum);
            var outAryX = [];
            var outAryY = [];
			var shapID = random(1,3)
			console.log(shapID)
            if (shapID == 1) {
                for (var i = 0; i < ballNum; i++) {
                    //XposAry1.push(i * 2);
                    //YposAry1.push(10);

                    outAryX.push(beginX + changeX * i);
                    var distanceX = Math.abs(outAryX[i] - oX);
                    var newY = Math.sqrt((radius * radius) - (distanceX * distanceX));
                    if (i % 2 == 0) {
                        outAryY.push(oY + newY);
                    } else {
                        outAryY.push(oY - newY);
                    }

                }

            } else if (shapID == 2) {
                for (var i = 0; i < ballNum; i++) {
                    outAryX.push(oX+i);
                    outAryY.push(oY+i);

                }
            }

            return [outAryX, outAryY]

        }


        function changeShap(oX,oY) {
			finish = false;//觸發繪圖
            //var shapID = $("#shapID").val();
			var shap =makeCircle(oX,oY);
            XposAry1 = shap[0];
            YposAry1 = shap[1];
        }

        loop();
		document.getElementById("myCanvas").addEventListener("click", function( event ) {
			changeShap(event.clientX,event.clientY)
		}, false);
    </script>
</body>

</html>
