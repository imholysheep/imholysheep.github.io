<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Bouncing balls</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
</head>

<body>
    <input type="button" value="change" onclick="changeShap()" />
    <input id="shapID" type="input" value="" />
    <canvas></canvas>

    <script>
        // setup canvas
        var canvas = document.querySelector('canvas'); //符合css選擇器
        var ctx = canvas.getContext('2d');
        var width = canvas.width = window.innerWidth;
        var height = canvas.height = window.innerHeight;
        var count = 0;
        //儲存彩球 
        var balls = [];
        // function to generate random number

        function random(min, max) { //起始值，最大值，回傳這區間的一個數
            var num = Math.floor(Math.random() * (max - min)) + min;
            return num;
        }
        //設定球體模型 (建構子) 屬性
        function Ball(x, y) {
            this.x = x; //random(0, width);
            this.y = y;
            / 2 / / random(0, height);
            this.velX = 0.01;
            this.velY = 0.01;
            this.color = 'rgb(' + random(20, 255) + ',' + random(20, 255) + ',' + random(200, 255) + ')';
            this.size = 2 //random(1, 2);
        }

        //繪製球體 建構子函式 原型繼承
        Ball.prototype.draw = function() {
            ctx.beginPath(); //聲明要在紙上畫出
            ctx.fillStyle = this.color; //要呈現的顏色
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI); //arc畫弧形 (中心xy，size半徑，始終角度0-2*180)
            ctx.fill(); //已完成形狀，並填滿fillStyle顏色
        }

        //碰撞換色
        Ball.prototype.collisionDetect = function() {
            for (j = 0; j < balls.length; j++) {
                //判斷為不同球
                if ((!(this.x === balls[j].x && this.y === balls[j].y && this.velX === balls[j].velX && this.velY === balls[j].velY))) {
                    //var dx = this.x;
                    var dx = this.x - balls[j].x;
                    //var dy = this.y;
                    var dy = this.y - balls[j].y;
                    var distance = Math.sqrt(dx * dx + dy * dy);

                    //判斷邊緣相撞
                    if (distance < this.size + balls[j].size) {
                        // if (distance < 1) {
                        balls[j].color = this.color = 'rgb(' + random(0, 255) + ',' + random(0, 255) + ',' + random(0, 255) + ')';
                        //balls[j].velX = -(this.velX);
                        //balls[j].velY = -(this.velY);

                    }
                }
            }
        }

        //偵測碰撞4ㄍ邊緣
        Ball.prototype.edgeDetect = function() {
            if ((this.x + this.size) >= width) {
                this.velX = -(this.velX);
            }

            if ((this.x - this.size) <= 0) {
                this.velX = -(this.velX);
            }

            if ((this.y + this.size) >= height) {
                this.velY = -(this.velY);
            }

            if ((this.y - this.size) <= 0) {
                this.velY = -(this.velY);
            }
        }

        //更新球的資料 
        //軌跡、位移量
        var s = 1;
        var times = 1;
        Ball.prototype.update = function() {

            //this.x += this.velX * 0.01;
            //this.y += this.velY * 0.01;
            this.x += ((20) * Math.cos(s * Math.PI / 72) - (1) * Math.cos(s / 6) * (s * Math.PI / 72)) * 0.1;
            this.y += ((20) * Math.sin(s * Math.PI / 72) - (1) * Math.sin(s / 6) * (s * Math.PI / 72)) * 0.1;
            count++;
            s++;
            //            if(count%200==0){
            //                //this.x =width/2;
            //                //this.y =height/2;
            //                s=times*20;
            //                times++;
            //            }

        }



        //萬花筒函式
        function Spirograph(ctx, R, r, O) {
            var x1 = R - O;
            var y1 = 0;
            var i = 1;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            do {
                if (i > 20000) break;
                var x2 = (R + r) * Math.cos(i * Math.PI / 72) - (r + O) * Math.cos(((R + r) / r) * (i * Math.PI / 72))
                var y2 = (R + r) * Math.sin(i * Math.PI / 72) - (r + O) * Math.sin(((R + r) / r) * (i * Math.PI / 72))
                ctx.lineTo(x2, y2);
                x1 = x2;
                y1 = y2;
                i++;
            } while (x2 != R - O && y2 != 0);
            ctx.stroke();
        }

        //畫布平移至抹點開始畫
        function drawSpirograph(ctx) {
            ctx.fillRect(0, 0, 300, 300);
            for (var i = 0; i < 3; i++) { //y軸平移
                for (var j = 0; j < 3; j++) { //x軸平移
                    ctx.save();
                    ctx.strokeStyle = "#9CFF00";
                    ctx.translate(50 + j * 100, 200 + i * 100);
                    Spirograph(ctx, 20 * (j + 2) / (j + 1), -8 * (i + 3) / (i + 1), 10);
                    ctx.restore();
                }
            }
        }
        //drawSpirograph(ctx);
        var XposAry1 = [];
        var YposAry1 = [];
        var XposAry2 = [];
        var YposAry2 = [];
        var ballNum = 1000;


        while (balls.length < ballNum) {
            var ball = new Ball(400, 400);
            balls.push(ball);
        }


        //造球
        var finish = false;
        var change = 0;

        function loop() {
            ctx.fillStyle = 'rgba(220,200,220,0.05)'; //畫格填滿的顏色
            ctx.fillRect(0, 0, width, height); //填滿區

            for (i = 0; i < balls.length; i++) {
                //自動換型
                /*if(!finish){
                	if(balls[i].x-5 >XposAry1[i]||balls[i].x+5 <XposAry1[i]||balls[i].y-5 >YposAry1[i]||balls[i].y+5 <YposAry1[i] ){
                		balls[i].x += (XposAry1[i]-balls[i].x)/10*Math.random();
                		balls[i].y += (YposAry1[i]-balls[i].y)/10*Math.random();
                	}else{
                		balls[i].color = '#000000';
                		balls[i].x=XposAry1[i];
                		balls[i].y=YposAry1[i];
                		//setTimeout(function(){
                		finish=true;
                		//},2000);
                		
                	}
		
                }else{
                if(balls[i].x-5 >XposAry2[i]||balls[i].x+5 <XposAry2[i]||balls[i].y-5 >YposAry2[i]||balls[i].y+5 <YposAry2[i] ){
                		balls[i].x += (XposAry2[i]-balls[i].x)/10*Math.random();
                		balls[i].y += (YposAry2[i]-balls[i].y)/10*Math.random();
                	}else{
                		balls[i].color = 'red';
                		balls[i].x=XposAry2[i];
                		balls[i].y=YposAry2[i];
                		setTimeout(function(){
                		finish=false;
                		},2000);
                	}
                }*/
                if (change == 0) {

                } else {
                    if (balls[i].x - 5 > XposAry1[i] || balls[i].x + 5 < XposAry1[i] || balls[i].y - 5 > YposAry1[i] || balls[i].y + 5 < YposAry1[i]) {
                        balls[i].x += (XposAry1[i] - balls[i].x) / 10 * Math.random();
                        balls[i].y += (YposAry1[i] - balls[i].y) / 10 * Math.random();
                    } else {
                        balls[i].color = '#000000';
                        balls[i].x = XposAry1[i];
                        balls[i].y = YposAry1[i];
                        //setTimeout(function(){
                        finish = true;
                        //},2000);
                    }
                }


                balls[i].draw();
                //balls[i].collisionDetect();
                //balls[i].edgeDetect();
                //console.log('x',balls[i].x)
                //console.log('y',balls[i].y)
                //balls[i].update();

            }
            count++; //從update搬來這裡

            if (count < 80000) {

                requestAnimationFrame(loop); //與瀏覽器繪製時間配合的
                //setTimeout(loop, 1000); //必較不好的繪製法

            };

        }

        function makeCircle(shapID) {
            var zeroX = width / 2;
            var zeroY = height / 2;
            var radius = 200;
            var beginX = zeroX - radius;
            var endX = zeroX - radius;
            var changeX = (radius * 2 / ballNum);
            var outAryX = [];
            var outAryY = [];
            //            for (var i = 0; i < ballNum; i++) {
            //                XposAry1.push(i * 2);
            //                YposAry1.push(100);
            //
            //                XposAry2.push(beginX + changeX * i);
            //                var distanceX = Math.abs(XposAry2[i] - zeroX);
            //                var newY = Math.sqrt((radius * radius) - (distanceX * distanceX));
            //                if (i % 2 == 0) {
            //                    YposAry2.push(zeroY + newY);
            //                } else {
            //                    YposAry2.push(zeroY - newY);
            //                }
            //
            //            }
            if (shapID == 1) {
                for (var i = 0; i < ballNum; i++) {
                    XposAry1.push(i * 2);
                    YposAry1.push(100);

                    outAryX.push(beginX + changeX * i);
                    var distanceX = Math.abs(outAryX[i] - zeroX);
                    var newY = Math.sqrt((radius * radius) - (distanceX * distanceX));
                    if (i % 2 == 0) {
                        outAryY.push(zeroY + newY);
                    } else {
                        outAryY.push(zeroY - newY);
                    }

                }

            } else if (shapID == 2) {
                for (var i = 0; i < ballNum; i++) {
                    outAryX.push(100*i);
                    outAryY.push(100*i);

                }
            }


            return [outAryX, outAryY]

        }


        function changeShap() {
            change = 1;
            var shapID = $("#shapID").val();

            XposAry1 = makeCircle(shapID)[0];
            YposAry1 = makeCircle(shapID)[1];
        }

        loop();

    </script>
</body>

</html>
