<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Bouncing balls</title>
</head>

<body>
    <canvas></canvas>
    <script>
        // setup canvas
        var canvas = document.querySelector('canvas'); //符合css選擇器
        var ctx = canvas.getContext('2d');
        var width = canvas.width = window.innerWidth;
        var height = canvas.height = window.innerHeight;
        var count = 0;
        // function to generate random number

        function random(min, max) { //起始值，最大值，回傳這區間的一個數
            var num = Math.floor(Math.random() * (max - min)) + min;
            return num;
        }
        //設定球體模型 (建構子) 屬性
        function Ball() {
            this.x = width / 2 //random(0, width);
            this.y = height / 2 // random(0, height);
            this.velX = 0.01;
            this.velY = 0.01;
            this.color = 'rgb(' + random(20, 255) + ',' + random(20, 255) + ',' + random(200, 255) + ')';
            this.size = random(1, 2);
        }

        //繪製球體 建構子函式 原型繼承
        Ball.prototype.draw = function() {
            ctx.beginPath(); //聲明要在紙上畫出
            ctx.fillStyle = this.color; //要呈現的顏色
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI); //arc畫弧形 (中心xy，size半徑，始終角度0-2*180)
            ctx.fill(); //已完成形狀，並填滿fillStyle顏色
        }

        // //建立新的球
        // var testBall = new Ball();
        // testBall.x
        // testBall.size
        // testBall.color
        // testBall.draw()

        //碰撞換色
        Ball.prototype.collisionDetect = function() {
            for (j = 0; j < balls.length; j++) {
                //判斷為不同球
                if ((!(this.x === balls[j].x && this.y === balls[j].y && this.velX === balls[j].velX && this.velY === balls[j].velY))) {
                    //var dx = this.x;
                    var dx = this.x - balls[j].x;
                    //var dy = this.y;
                    var dy = this.y - balls[j].y;
                    var distance = Math.sqrt(dx * dx + dy * dy);

                    //判斷邊緣相撞
                    if (distance < this.size + balls[j].size) {
                        // if (distance < 1) {
                        balls[j].color = this.color = 'rgb(' + random(0, 255) + ',' + random(0, 255) + ',' + random(0, 255) + ')';
                        //balls[j].velX = -(this.velX);
                        //balls[j].velY = -(this.velY);

                    }
                }
            }
        }

        //偵測碰撞4ㄍ邊緣
        Ball.prototype.edgeDetect = function() {
            if ((this.x + this.size) >= width) {
                this.velX = -(this.velX);
            }

            if ((this.x - this.size) <= 0) {
                this.velX = -(this.velX);
            }

            if ((this.y + this.size) >= height) {
                this.velY = -(this.velY);
            }

            if ((this.y - this.size) <= 0) {
                this.velY = -(this.velY);
            }
        }

        //更新球的資料 
        //軌跡、位移量
        var s = 1;
        var times = 1;
        Ball.prototype.update = function() {
            
            //this.x += this.velX * 0.01;
            //this.y += this.velY * 0.01;
            this.x += ((20) * Math.cos(s * Math.PI / 72) - (1) * Math.cos(s / 6) * (s * Math.PI / 72))*0.1;
            this.y += ((20) * Math.sin(s * Math.PI / 72) - (1) * Math.sin(s / 6) * (s * Math.PI / 72))*0.1;
            count++;
            s++;
//            if(count%200==0){
//                //this.x =width/2;
//                //this.y =height/2;
//                s=times*20;
//                times++;
//            }

        }

        //儲存彩球 
        var balls = [];

        //萬花筒函式
        function Spirograph(ctx, R, r, O) {
            var x1 = R - O;
            var y1 = 0;
            var i = 1;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            do {
                if (i > 20000) break;
                var x2 = (R + r) * Math.cos(i * Math.PI / 72) - (r + O) * Math.cos(((R + r) / r) * (i * Math.PI / 72))
                var y2 = (R + r) * Math.sin(i * Math.PI / 72) - (r + O) * Math.sin(((R + r) / r) * (i * Math.PI / 72))
                ctx.lineTo(x2, y2);
                x1 = x2;
                y1 = y2;
                i++;
            } while (x2 != R - O && y2 != 0);
            ctx.stroke();
        }

        //畫布平移至抹點開始畫
        function drawSpirograph(ctx) {
            ctx.fillRect(0, 0, 300, 300);
            for (var i = 0; i < 3; i++) { //y軸平移
                for (var j = 0; j < 3; j++) { //x軸平移
                    ctx.save();
                    ctx.strokeStyle = "#9CFF00";
                    ctx.translate(50 + j * 100, 200 + i * 100);
                    Spirograph(ctx, 20 * (j + 2) / (j + 1), -8 * (i + 3) / (i + 1), 10);
                    ctx.restore();
                }
            }
        }
        drawSpirograph(ctx);

        //造球
        function loop() {
            ctx.fillStyle = 'rgba(220,200,220,0.25)'; //畫格填滿的顏色
            //ctx.fillRect(0, 0, width, height); //填滿區

            while (balls.length < 1) {
                var ball = new Ball();
                balls.push(ball);
            }

            for (i = 0; i < balls.length; i++) {
                balls[i].draw();
                balls[i].collisionDetect();
                balls[i].edgeDetect();

                balls[i].update();

            }

            if (count < 10000) {

                requestAnimationFrame(loop); //與瀏覽器繪製時間配合的
                //setTimeout(loop, 1000); //必較不好的繪製法

            };

        }

        loop();

    </script>
</body>

</html>
