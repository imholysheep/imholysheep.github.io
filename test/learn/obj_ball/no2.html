<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Bouncing balls</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
</head>

<body>
    <input type="button" value="change" onclick="changeShap()" />
    <input id="shapID" type="input" value="" />
    <canvas id="myCanvas"></canvas>

    <script>
        // setup canvas
        var canvas = document.querySelector('canvas'); //符合css選擇器
        var ctx = canvas.getContext('2d');
        var width = canvas.width = window.innerWidth;
        var height = canvas.height = window.innerHeight;
        var zeroX = width / 2;
        var zeroY = height / 2;
        var count = 0;
        //儲存彩球 
        var balls = [];
        // function to generate random number
        var XposAry1 = [];
        var YposAry1 = [];
        var ballNum = 1000;
        var baseShap = makeBaseAnimine();
        var XposAry2 = baseShap[0];
        var YposAry2 = baseShap[1];




        function random(min, max) { //起始值，最大值，回傳這區間的一個數
            var num = Math.floor(Math.random() * (max - min)) + min;
            return num;
        }
        //設定球體模型 (建構子) 屬性
        function Ball(x, y) {
            this.x = x; //random(0, width);
            this.y = y;
            / 2 / / random(0, height);
            this.velX = 10;
            this.velY = 10;
            this.color = "gray" //'rgb(' + random(20, 255) + ',' + random(20, 255) + ',' + random(200, 255) + ')';
            this.size = 2 //random(1, 2);
        }

        //繪製球體 建構子函式 原型繼承
        Ball.prototype.draw = function() {
            ctx.beginPath(); //聲明要在紙上畫出
            ctx.fillStyle = this.color; //要呈現的顏色
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI); //arc畫弧形 (中心xy，size半徑，始終角度0-2*180)
            ctx.fill(); //已完成形狀，並填滿fillStyle顏色
        }

        //碰撞換色
        Ball.prototype.collisionDetect = function() {
            for (j = 0; j < balls.length; j++) {
                //判斷為不同球
                if ((!(this.x === balls[j].x && this.y === balls[j].y && this.velX === balls[j].velX && this.velY === balls[j].velY))) {
                    //var dx = this.x;
                    var dx = this.x - balls[j].x;
                    //var dy = this.y;
                    var dy = this.y - balls[j].y;
                    var distance = Math.sqrt(dx * dx + dy * dy);

                    //判斷邊緣相撞
                    if (distance < this.size + balls[j].size) {
                        // if (distance < 1) {
                        balls[j].color = this.color = 'rgb(' + random(0, 255) + ',' + random(0, 255) + ',' + random(0, 255) + ')';
                        //balls[j].velX = -(this.velX);
                        //balls[j].velY = -(this.velY);

                    }
                }
            }
        }

        //偵測碰撞4ㄍ邊緣
        //(重置)
        Ball.prototype.edgeDetect = function() {
            if ((this.y - this.size) <= 0 || (this.x + this.size) >= width || (this.y + this.size) >= height || (this.y - this.size) <= 0) {
                //this.velY = -(this.velY);
                this.x = zeroX + this.x;
                this.y = zeroY + this.y;
            }
        }

        //更新球的資料 
        //軌跡、位移量
        var s = 1;
        var times = 1;
        Ball.prototype.update = function() {

            //this.x += this.velX * 0.01;
            //this.y += this.velY * 0.01;
            this.x += ((20) * Math.cos(s * Math.PI / 72) - (1) * Math.cos(s / 6) * (s * Math.PI / 72)) * 0.1;
            this.y += ((20) * Math.sin(s * Math.PI / 72) - (1) * Math.sin(s / 6) * (s * Math.PI / 72)) * 0.1;
            count++;
            s++;
            //            if(count%200==0){
            //                //this.x =width/2;
            //                //this.y =height/2;
            //                s=times*20;
            //                times++;
            //            }

        }

        //萬花筒函式
        function Spirograph(ctx, R, r, O) {
            var x1 = R - O;
            var y1 = 0;
            var i = 1;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            do {
                if (i > 20000) break;
                var x2 = (R + r) * Math.cos(i * Math.PI / 72) - (r + O) * Math.cos(((R + r) / r) * (i * Math.PI / 72))
                var y2 = (R + r) * Math.sin(i * Math.PI / 72) - (r + O) * Math.sin(((R + r) / r) * (i * Math.PI / 72))
                ctx.lineTo(x2, y2);
                x1 = x2;
                y1 = y2;
                i++;
            } while (x2 != R - O && y2 != 0);
            ctx.stroke();
        }

        //畫布平移至抹點開始畫
        function drawSpirograph(ctx) {
            ctx.fillRect(0, 0, 300, 300);
            for (var i = 0; i < 3; i++) { //y軸平移
                for (var j = 0; j < 3; j++) { //x軸平移
                    ctx.save();
                    ctx.strokeStyle = "#9CFF00";
                    ctx.translate(50 + j * 100, 200 + i * 100);
                    Spirograph(ctx, 20 * (j + 2) / (j + 1), -8 * (i + 3) / (i + 1), 10);
                    ctx.restore();
                }
            }
        }
        //drawSpirograph(ctx);

        while (balls.length < ballNum) {
            var ball = new Ball(400, 400);
            balls.push(ball);
        }


        //造球
        var finish = true;
        var change = 0;

        function loop() {
            console.log(finish)
            ctx.fillStyle = 'rgba(200,200,200,0.8)'; //畫格填滿的顏色
            ctx.fillRect(0, 0, width, height); //填滿區
            var wave =0;
            for (i = 0; i < balls.length; i++) {
                //balls[i].edgeDetect();
                if (finish == false && change > 100) {
                    //定時時間到，回基底動畫
                    finish = true;
                } else if (finish == false) {
                    if (balls[i].x - 5 > XposAry1[i] || balls[i].x + 5 < XposAry1[i] || balls[i].y - 5 > YposAry1[i] || balls[i].y + 5 < YposAry1[i]) {
                        balls[i].x += (XposAry1[i] - balls[i].x) / 10 * Math.random();
                        balls[i].y += (YposAry1[i] - balls[i].y) / 10 * Math.random();
                    } else {
                        //到達變形定位;
                        balls[i].x = XposAry1[i];
                        balls[i].y = YposAry1[i];
                        if (i == balls.length - 1) {
                            //到定位計時
                            change++;
                        }
                    }
                } else if (finish == true) {
                    change = 0;
                    //回到基底動畫位置
                    if (balls[i].x - 5 > XposAry2[i] || balls[i].x + 5 < XposAry2[i] || balls[i].y - 5 > YposAry2[i] || balls[i].y + 5 < YposAry2[i]) {
                        balls[i].x += (XposAry2[i] - balls[i].x) / 10 * Math.random();
                        balls[i].y += (YposAry2[i] - balls[i].y) / 10 * Math.random();
                    } else {
                        //基底動畫
                        if(wave<100){
                            wave++;
                        }else{
                            //wave=-10;
                        }
                        
                        baseShap = makeBaseAnimine(wave);
                        XposAry2 = baseShap[0];
                        YposAry2 = baseShap[1];
                        balls[i].x += 0.1 //* random(-20, 20);
                        balls[i].y += 0.1 //* random(-10, 10);
                    }

                }

                balls[i].draw();
            }
            count++; //從update搬來這裡
            if (count < 80000) {
                requestAnimationFrame(loop); //與瀏覽器繪製時間配合的
                //setTimeout(loop, 1000); //必較不好的繪製法
            };

        }

        function makeBaseAnimine(wave) {
            var outAryX = [];
            var outAryY = [];
            var group = "";
            for (var i = 0; i < ballNum; i++) {
                var _A = Math.abs(4 * Math.cos(2 * i));
                var pos = Math.exp(-_A * i / width) * Math.sin(4 * Math.PI * (i + 10) / width);
                outAryX.push(i-zeroX);
                outAryY.push(pos * wave + zeroY);
                //for (var j = 0; j < group; j++) {}
            }
            return [outAryX, outAryY]
        }

        function makeCircle(oX, oY) {
            var outAryX = [];
            var outAryY = [];
            var shapID = random(3, 4)
            console.log(shapID)
            if (shapID == 1) {
                var radius = random(50, 200);
                var beginX = oX - radius;
                var endX = oX - radius;
                var changeX = (radius * 2 / ballNum);
                for (var i = 0; i < ballNum; i++) {
                    //XposAry1.push(i * 2);
                    //YposAry1.push(10);
                    outAryX.push(beginX + changeX * i);
                    var distanceX = Math.abs(outAryX[i] - oX);
                    var newY = Math.sqrt((radius * radius) - (distanceX * distanceX));
                    if (i % 2 == 0) {
                        outAryY.push(oY + newY);
                    } else {
                        outAryY.push(oY - newY);
                    }
                }
            } else if (shapID == 2) {
                for (var i = 0; i < ballNum; i++) {
                    outAryX.push(oX + i);
                    outAryY.push(oY + i);
                }
            } else if (shapID == 3) {
                var R, r, O;
                R = 20 * 4 / 2;
                r = -8 * 7 / 1;
                O = 10;
                var x1 = R - O;
                var y1 = 0;
                var x2, y2;
                for (var i = 0; i < 3; i++) { //y軸平移
                    for (var j = 0; j < 3; j++) { //x軸平移
                        R = random(12, 89) * (j + 2) / (j + 1);
                        r = random(-50, 63) * (i + 3) / (i + 1);
                        for (var i = 0; i < ballNum; i++) {
                            x2 = (R + r) * Math.cos(i * Math.PI / 72) - (r + O) * Math.cos(((R + r) / r) * (i * Math.PI / 72)) + oX
                            y2 = (R + r) * Math.sin(i * Math.PI / 72) - (r + O) * Math.sin(((R + r) / r) * (i * Math.PI / 72)) + oY
                            x1 = x2;
                            y1 = y2;
                            //原點為x2 == R-O && y2 == 0 

                            outAryX.push(x2);
                            outAryY.push(y2);
                        }
                    }
                }
                for (var i = 0; i < ballNum; i++) {
                    x2 = (R + r) * Math.cos(i * Math.PI / 72) - (r + O) * Math.cos(((R + r) / r) * (i * Math.PI / 72)) + oX
                    y2 = (R + r) * Math.sin(i * Math.PI / 72) - (r + O) * Math.sin(((R + r) / r) * (i * Math.PI / 72)) + oY
                    x1 = x2;
                    y1 = y2;
                    outAryX.push(x2);
                    outAryY.push(y2);
                }
            }

            return [outAryX, outAryY]

        }


        function changeShap(oX, oY) {
            finish = false; //觸發繪圖
            //var shapID = $("#shapID").val();
            var shap = makeCircle(oX, oY);
            XposAry1 = shap[0];
            YposAry1 = shap[1];
        }

        loop();
        document.getElementById("myCanvas").addEventListener("click", function(event) {
            changeShap(event.clientX, event.clientY)
        }, false);

    </script>
</body>

</html>
